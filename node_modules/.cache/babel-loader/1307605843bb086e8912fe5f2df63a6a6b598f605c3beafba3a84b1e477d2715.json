{"ast":null,"code":"import { encode, instantiate } from 'media-encoder-host';\nimport { MultiBufferDataView } from 'multi-buffer-data-view';\nimport { on } from 'subscribable-things';\nexport const createWebmPcmMediaRecorderFactory = (createBlobEvent, createInvalidModificationError, createNotSupportedError, decodeWebMChunk, readVariableSizeInteger) => {\n  return (eventTarget, nativeMediaRecorderConstructor, mediaStream, mimeType) => {\n    const audioTracks = mediaStream.getAudioTracks();\n    const bufferedArrayBuffers = [];\n    const nativeMediaRecorder = new nativeMediaRecorderConstructor(mediaStream, {\n      mimeType: 'audio/webm;codecs=pcm'\n    });\n    let promisedPartialRecording = null;\n    let stopRecording = () => {}; // tslint:disable-line:no-empty\n    const dispatchDataAvailableEvent = arrayBuffers => {\n      eventTarget.dispatchEvent(createBlobEvent('dataavailable', {\n        data: new Blob(arrayBuffers, {\n          type: mimeType\n        })\n      }));\n    };\n    const requestNextPartialRecording = async (encoderId, timeslice) => {\n      const arrayBuffers = await encode(encoderId, timeslice);\n      if (nativeMediaRecorder.state === 'inactive') {\n        bufferedArrayBuffers.push(...arrayBuffers);\n      } else {\n        dispatchDataAvailableEvent(arrayBuffers);\n        promisedPartialRecording = requestNextPartialRecording(encoderId, timeslice);\n      }\n    };\n    const stop = () => {\n      if (nativeMediaRecorder.state === 'inactive') {\n        return;\n      }\n      if (promisedPartialRecording !== null) {\n        promisedPartialRecording.catch(() => {\n          /* @todo Only catch the errors caused by a duplicate call to encode. */\n        });\n        promisedPartialRecording = null;\n      }\n      stopRecording();\n      stopRecording = () => {}; // tslint:disable-line:no-empty\n      nativeMediaRecorder.stop();\n    };\n    nativeMediaRecorder.addEventListener('error', event => {\n      stop();\n      // Bug #3 & #4: Chrome throws an error event without any error.\n      eventTarget.dispatchEvent(new ErrorEvent('error', {\n        error: event.error === undefined ? createInvalidModificationError() : event.error\n      }));\n    });\n    nativeMediaRecorder.addEventListener('pause', () => eventTarget.dispatchEvent(new Event('pause')));\n    nativeMediaRecorder.addEventListener('resume', () => eventTarget.dispatchEvent(new Event('resume')));\n    nativeMediaRecorder.addEventListener('start', () => eventTarget.dispatchEvent(new Event('start')));\n    return {\n      get mimeType() {\n        return mimeType;\n      },\n      get state() {\n        return nativeMediaRecorder.state;\n      },\n      pause() {\n        return nativeMediaRecorder.pause();\n      },\n      resume() {\n        return nativeMediaRecorder.resume();\n      },\n      start(timeslice) {\n        var _a, _b;\n        /*\n         * Bug #6: Chrome will emit a blob without any data when asked to encode a MediaStream with a video track into an audio\n         * codec.\n         */\n        if (mediaStream.getVideoTracks().length > 0) {\n          throw createNotSupportedError();\n        }\n        if (nativeMediaRecorder.state === 'inactive') {\n          // Bug #19: Chrome does not expose the correct channelCount property right away.\n          // @todo TypeScript v4.4.2 removed the channelCount property from the MediaTrackSettings interface.\n          const channelCount = ((_a = audioTracks[0]) === null || _a === void 0 ? void 0 : _a.getSettings()).channelCount;\n          const sampleRate = (_b = audioTracks[0]) === null || _b === void 0 ? void 0 : _b.getSettings().sampleRate;\n          if (channelCount === undefined) {\n            throw new Error('The channelCount is not defined.');\n          }\n          if (sampleRate === undefined) {\n            throw new Error('The sampleRate is not defined.');\n          }\n          let isRecording = false;\n          let isStopped = false;\n          // Bug #9: Chrome sometimes fires more than one dataavailable event while being inactive.\n          let pendingInvocations = 0;\n          let promisedDataViewElementTypeEncoderIdAndPort = instantiate(mimeType, sampleRate);\n          stopRecording = () => {\n            isStopped = true;\n          };\n          const removeEventListener = on(nativeMediaRecorder, 'dataavailable')(_ref => {\n            let {\n              data\n            } = _ref;\n            pendingInvocations += 1;\n            promisedDataViewElementTypeEncoderIdAndPort = promisedDataViewElementTypeEncoderIdAndPort.then(async _ref2 => {\n              let {\n                dataView = null,\n                elementType = null,\n                encoderId,\n                port\n              } = _ref2;\n              const arrayBuffer = await data.arrayBuffer();\n              pendingInvocations -= 1;\n              const currentDataView = dataView === null ? new MultiBufferDataView([arrayBuffer]) : new MultiBufferDataView([...dataView.buffers, arrayBuffer], dataView.byteOffset);\n              if (!isRecording && nativeMediaRecorder.state === 'recording' && !isStopped) {\n                const lengthAndValue = readVariableSizeInteger(currentDataView, 0);\n                if (lengthAndValue === null) {\n                  return {\n                    dataView: currentDataView,\n                    elementType,\n                    encoderId,\n                    port\n                  };\n                }\n                const {\n                  value\n                } = lengthAndValue;\n                if (value !== 172351395) {\n                  return {\n                    dataView,\n                    elementType,\n                    encoderId,\n                    port\n                  };\n                }\n                isRecording = true;\n              }\n              const {\n                currentElementType,\n                offset,\n                contents\n              } = decodeWebMChunk(currentDataView, elementType, channelCount);\n              const remainingDataView = offset < currentDataView.byteLength ? new MultiBufferDataView(currentDataView.buffers, currentDataView.byteOffset + offset) : null;\n              contents.forEach(content => port.postMessage(content, content.map(_ref3 => {\n                let {\n                  buffer\n                } = _ref3;\n                return buffer;\n              })));\n              if (pendingInvocations === 0 && (nativeMediaRecorder.state === 'inactive' || isStopped)) {\n                encode(encoderId, null).then(arrayBuffers => {\n                  dispatchDataAvailableEvent([...bufferedArrayBuffers, ...arrayBuffers]);\n                  bufferedArrayBuffers.length = 0;\n                  eventTarget.dispatchEvent(new Event('stop'));\n                });\n                port.postMessage([]);\n                port.close();\n                removeEventListener();\n              }\n              return {\n                dataView: remainingDataView,\n                elementType: currentElementType,\n                encoderId,\n                port\n              };\n            });\n          });\n          if (timeslice !== undefined) {\n            promisedDataViewElementTypeEncoderIdAndPort.then(_ref4 => {\n              let {\n                encoderId\n              } = _ref4;\n              return promisedPartialRecording = requestNextPartialRecording(encoderId, timeslice);\n            });\n          }\n        }\n        nativeMediaRecorder.start(100);\n      },\n      stop\n    };\n  };\n};","map":{"version":3,"mappings":"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","names":["encode","instantiate","MultiBufferDataView","on","createWebmPcmMediaRecorderFactory","createBlobEvent","createInvalidModificationError","createNotSupportedError","decodeWebMChunk","readVariableSizeInteger","eventTarget","nativeMediaRecorderConstructor","mediaStream","mimeType","audioTracks","getAudioTracks","bufferedArrayBuffers","nativeMediaRecorder","promisedPartialRecording","stopRecording","dispatchDataAvailableEvent","arrayBuffers","dispatchEvent","data","Blob","type","requestNextPartialRecording","encoderId","timeslice","state","push","stop","catch","addEventListener","event","ErrorEvent","error","undefined","Event","pause","resume","start","getVideoTracks","length","channelCount","getSettings","sampleRate","Error","isRecording","isStopped","pendingInvocations","promisedDataViewElementTypeEncoderIdAndPort","removeEventListener","then","dataView","elementType","port","arrayBuffer","currentDataView","buffers","byteOffset","lengthAndValue","value","currentElementType","offset","contents","remainingDataView","byteLength","forEach","content","postMessage","map","buffer","close"],"sources":["/home/drevil/react/drum-machine-2/node_modules/extendable-media-recorder/src/factories/webm-pcm-media-recorder.ts"],"sourcesContent":["import { encode, instantiate } from 'media-encoder-host';\nimport { MultiBufferDataView } from 'multi-buffer-data-view';\nimport { on } from 'subscribable-things';\nimport { TPromisedDataViewElementTypeEncoderIdAndPort, TRecordingState, TWebmPcmMediaRecorderFactoryFactory } from '../types';\n\nexport const createWebmPcmMediaRecorderFactory: TWebmPcmMediaRecorderFactoryFactory = (\n    createBlobEvent,\n    createInvalidModificationError,\n    createNotSupportedError,\n    decodeWebMChunk,\n    readVariableSizeInteger\n) => {\n    return (eventTarget, nativeMediaRecorderConstructor, mediaStream, mimeType) => {\n        const audioTracks = mediaStream.getAudioTracks();\n        const bufferedArrayBuffers: ArrayBuffer[] = [];\n        const nativeMediaRecorder = new nativeMediaRecorderConstructor(mediaStream, { mimeType: 'audio/webm;codecs=pcm' });\n\n        let promisedPartialRecording: null | Promise<void> = null;\n        let stopRecording = () => {}; // tslint:disable-line:no-empty\n\n        const dispatchDataAvailableEvent = (arrayBuffers: ArrayBuffer[]): void => {\n            eventTarget.dispatchEvent(createBlobEvent('dataavailable', { data: new Blob(arrayBuffers, { type: mimeType }) }));\n        };\n\n        const requestNextPartialRecording = async (encoderId: number, timeslice: number): Promise<void> => {\n            const arrayBuffers = await encode(encoderId, timeslice);\n\n            if (nativeMediaRecorder.state === 'inactive') {\n                bufferedArrayBuffers.push(...arrayBuffers);\n            } else {\n                dispatchDataAvailableEvent(arrayBuffers);\n\n                promisedPartialRecording = requestNextPartialRecording(encoderId, timeslice);\n            }\n        };\n\n        const stop = (): void => {\n            if (nativeMediaRecorder.state === 'inactive') {\n                return;\n            }\n\n            if (promisedPartialRecording !== null) {\n                promisedPartialRecording.catch(() => {\n                    /* @todo Only catch the errors caused by a duplicate call to encode. */\n                });\n                promisedPartialRecording = null;\n            }\n\n            stopRecording();\n            stopRecording = () => {}; // tslint:disable-line:no-empty\n\n            nativeMediaRecorder.stop();\n        };\n\n        nativeMediaRecorder.addEventListener('error', (event) => {\n            stop();\n            // Bug #3 & #4: Chrome throws an error event without any error.\n            eventTarget.dispatchEvent(\n                new ErrorEvent('error', {\n                    error: (<ErrorEvent>event).error === undefined ? createInvalidModificationError() : (<ErrorEvent>event).error\n                })\n            );\n        });\n        nativeMediaRecorder.addEventListener('pause', () => eventTarget.dispatchEvent(new Event('pause')));\n        nativeMediaRecorder.addEventListener('resume', () => eventTarget.dispatchEvent(new Event('resume')));\n        nativeMediaRecorder.addEventListener('start', () => eventTarget.dispatchEvent(new Event('start')));\n\n        return {\n            get mimeType(): string {\n                return mimeType;\n            },\n\n            get state(): TRecordingState {\n                return nativeMediaRecorder.state;\n            },\n\n            pause(): void {\n                return nativeMediaRecorder.pause();\n            },\n\n            resume(): void {\n                return nativeMediaRecorder.resume();\n            },\n\n            start(timeslice?: number): void {\n                /*\n                 * Bug #6: Chrome will emit a blob without any data when asked to encode a MediaStream with a video track into an audio\n                 * codec.\n                 */\n                if (mediaStream.getVideoTracks().length > 0) {\n                    throw createNotSupportedError();\n                }\n\n                if (nativeMediaRecorder.state === 'inactive') {\n                    // Bug #19: Chrome does not expose the correct channelCount property right away.\n                    // @todo TypeScript v4.4.2 removed the channelCount property from the MediaTrackSettings interface.\n                    const channelCount = (<MediaTrackSettings & { channelCount?: number }>audioTracks[0]?.getSettings()).channelCount;\n                    const sampleRate = audioTracks[0]?.getSettings().sampleRate;\n\n                    if (channelCount === undefined) {\n                        throw new Error('The channelCount is not defined.');\n                    }\n\n                    if (sampleRate === undefined) {\n                        throw new Error('The sampleRate is not defined.');\n                    }\n\n                    let isRecording = false;\n                    let isStopped = false;\n                    // Bug #9: Chrome sometimes fires more than one dataavailable event while being inactive.\n                    let pendingInvocations = 0;\n                    let promisedDataViewElementTypeEncoderIdAndPort: TPromisedDataViewElementTypeEncoderIdAndPort = instantiate(\n                        mimeType,\n                        sampleRate\n                    );\n\n                    stopRecording = () => {\n                        isStopped = true;\n                    };\n\n                    const removeEventListener = on(\n                        nativeMediaRecorder,\n                        'dataavailable'\n                    )(({ data }) => {\n                        pendingInvocations += 1;\n\n                        promisedDataViewElementTypeEncoderIdAndPort = promisedDataViewElementTypeEncoderIdAndPort.then(\n                            async ({ dataView = null, elementType = null, encoderId, port }) => {\n                                const arrayBuffer = await data.arrayBuffer();\n\n                                pendingInvocations -= 1;\n\n                                const currentDataView =\n                                    dataView === null\n                                        ? new MultiBufferDataView([arrayBuffer])\n                                        : new MultiBufferDataView([...dataView.buffers, arrayBuffer], dataView.byteOffset);\n\n                                if (!isRecording && nativeMediaRecorder.state === 'recording' && !isStopped) {\n                                    const lengthAndValue = readVariableSizeInteger(currentDataView, 0);\n\n                                    if (lengthAndValue === null) {\n                                        return { dataView: currentDataView, elementType, encoderId, port };\n                                    }\n\n                                    const { value } = lengthAndValue;\n\n                                    if (value !== 172351395) {\n                                        return { dataView, elementType, encoderId, port };\n                                    }\n\n                                    isRecording = true;\n                                }\n\n                                const { currentElementType, offset, contents } = decodeWebMChunk(\n                                    currentDataView,\n                                    elementType,\n                                    channelCount\n                                );\n                                const remainingDataView =\n                                    offset < currentDataView.byteLength\n                                        ? new MultiBufferDataView(currentDataView.buffers, currentDataView.byteOffset + offset)\n                                        : null;\n\n                                contents.forEach((content) =>\n                                    port.postMessage(\n                                        content,\n                                        content.map(({ buffer }) => buffer)\n                                    )\n                                );\n\n                                if (pendingInvocations === 0 && (nativeMediaRecorder.state === 'inactive' || isStopped)) {\n                                    encode(encoderId, null).then((arrayBuffers) => {\n                                        dispatchDataAvailableEvent([...bufferedArrayBuffers, ...arrayBuffers]);\n\n                                        bufferedArrayBuffers.length = 0;\n\n                                        eventTarget.dispatchEvent(new Event('stop'));\n                                    });\n\n                                    port.postMessage([]);\n                                    port.close();\n\n                                    removeEventListener();\n                                }\n\n                                return { dataView: remainingDataView, elementType: currentElementType, encoderId, port };\n                            }\n                        );\n                    });\n\n                    if (timeslice !== undefined) {\n                        promisedDataViewElementTypeEncoderIdAndPort.then(\n                            ({ encoderId }) => (promisedPartialRecording = requestNextPartialRecording(encoderId, timeslice))\n                        );\n                    }\n                }\n\n                nativeMediaRecorder.start(100);\n            },\n\n            stop\n        };\n    };\n};\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}