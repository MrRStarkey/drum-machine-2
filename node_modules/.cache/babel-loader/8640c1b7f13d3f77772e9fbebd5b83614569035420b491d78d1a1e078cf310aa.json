{"ast":null,"code":"'use strict';\n\nvar PropTypes = require('prop-types');\nvar React = require('react');\nfunction getPinchProps(touches) {\n  return {\n    touches: Array.prototype.map.call(touches, function copyTouch(touch) {\n      return {\n        identifier: touch.identifier,\n        pageX: touch.pageX,\n        pageY: touch.pageY\n      };\n    }),\n    center: {\n      x: (touches[0].pageX + touches[1].pageX) / 2,\n      y: (touches[0].pageY + touches[1].pageY) / 2\n    },\n    angle: Math.atan() * (touches[1].pageY - touches[0].pageY) / (touches[1].pageX - touches[0].pageX) * 180 / Math.PI,\n    distance: Math.sqrt(Math.pow(Math.abs(touches[1].pageX - touches[0].pageX), 2) + Math.pow(Math.abs(touches[1].pageY - touches[0].pageY), 2))\n  };\n}\nvar Mixin = {\n  propTypes: {\n    onPinchStart: PropTypes.func,\n    // fires when a pinch gesture is started\n    onPinchMove: PropTypes.func,\n    // fires on every touch-move when a pinch action is active\n    onPinchEnd: PropTypes.func // fires when a pinch action ends\n  },\n\n  onPinchStart: function onPinchStart(event) {\n    // in case the two touches didn't start exactly at the same time\n    if (this._initialTouch) {\n      this.endTouch();\n    }\n    var touches = event.touches;\n    this._initialPinch = getPinchProps(touches);\n    this._initialPinch = Object.assign(this._initialPinch, {\n      displacement: {\n        x: 0,\n        y: 0\n      },\n      displacementVelocity: {\n        x: 0,\n        y: 0\n      },\n      rotation: 0,\n      rotationVelocity: 0,\n      zoom: 1,\n      zoomVelocity: 0,\n      time: Date.now()\n    });\n    this._lastPinch = this._initialPinch;\n    this.props.onPinchStart && this.props.onPinchStart(this._initialPinch, event);\n  },\n  onPinchMove: function onPinchMove(event) {\n    if (this._initialTouch) {\n      this.endTouch();\n    }\n    var touches = event.touches;\n    if (touches.length !== 2) {\n      return this.onPinchEnd(event); // bail out before disaster\n    }\n\n    var currentPinch = touches[0].identifier === this._initialPinch.touches[0].identifier && touches[1].identifier === this._initialPinch.touches[1].identifier ? getPinchProps(touches) // the touches are in the correct order\n    : touches[1].identifier === this._initialPinch.touches[0].identifier && touches[0].identifier === this._initialPinch.touches[1].identifier ? getPinchProps(touches.reverse()) // the touches have somehow changed order\n    : getPinchProps(touches); // something is wrong, but we still have two touch-points, so we try not to fail\n\n    currentPinch.displacement = {\n      x: currentPinch.center.x - this._initialPinch.center.x,\n      y: currentPinch.center.y - this._initialPinch.center.y\n    };\n    currentPinch.time = Date.now();\n    var timeSinceLastPinch = currentPinch.time - this._lastPinch.time;\n    currentPinch.displacementVelocity = {\n      x: (currentPinch.displacement.x - this._lastPinch.displacement.x) / timeSinceLastPinch,\n      y: (currentPinch.displacement.y - this._lastPinch.displacement.y) / timeSinceLastPinch\n    };\n    currentPinch.rotation = currentPinch.angle - this._initialPinch.angle;\n    currentPinch.rotationVelocity = currentPinch.rotation - this._lastPinch.rotation / timeSinceLastPinch;\n    currentPinch.zoom = currentPinch.distance / this._initialPinch.distance;\n    currentPinch.zoomVelocity = (currentPinch.zoom - this._lastPinch.zoom) / timeSinceLastPinch;\n    this.props.onPinchMove && this.props.onPinchMove(currentPinch, event);\n    this._lastPinch = currentPinch;\n  },\n  onPinchEnd: function onPinchEnd(event) {\n    // TODO use helper to order touches by identifier and use actual values on touchEnd.\n    var currentPinch = Object.assign({}, this._lastPinch);\n    currentPinch.time = Date.now();\n    if (currentPinch.time - this._lastPinch.time > 16) {\n      currentPinch.displacementVelocity = 0;\n      currentPinch.rotationVelocity = 0;\n      currentPinch.zoomVelocity = 0;\n    }\n    this.props.onPinchEnd && this.props.onPinchEnd(currentPinch, event);\n    this._initialPinch = this._lastPinch = null;\n\n    // If one finger is still on screen, it should start a new touch event for swiping etc\n    // But it should never fire an onTap or onPress event.\n    // Since there is no support swipes yet, this should be disregarded for now\n    // if (event.touches.length === 1) {\n    // \tthis.onTouchStart(event);\n    // }\n  }\n};\n\nmodule.exports = Mixin;","map":{"version":3,"names":["PropTypes","require","React","getPinchProps","touches","Array","prototype","map","call","copyTouch","touch","identifier","pageX","pageY","center","x","y","angle","Math","atan","PI","distance","sqrt","pow","abs","Mixin","propTypes","onPinchStart","func","onPinchMove","onPinchEnd","event","_initialTouch","endTouch","_initialPinch","Object","assign","displacement","displacementVelocity","rotation","rotationVelocity","zoom","zoomVelocity","time","Date","now","_lastPinch","props","length","currentPinch","reverse","timeSinceLastPinch","module","exports"],"sources":["/home/drevil/react/drum-machine-2/node_modules/react-tappable/lib/PinchableMixin.js"],"sourcesContent":["'use strict';\n\nvar PropTypes = require('prop-types');\nvar React = require('react');\n\nfunction getPinchProps(touches) {\n\treturn {\n\t\ttouches: Array.prototype.map.call(touches, function copyTouch(touch) {\n\t\t\treturn { identifier: touch.identifier, pageX: touch.pageX, pageY: touch.pageY };\n\t\t}),\n\t\tcenter: { x: (touches[0].pageX + touches[1].pageX) / 2, y: (touches[0].pageY + touches[1].pageY) / 2 },\n\t\tangle: Math.atan() * (touches[1].pageY - touches[0].pageY) / (touches[1].pageX - touches[0].pageX) * 180 / Math.PI,\n\t\tdistance: Math.sqrt(Math.pow(Math.abs(touches[1].pageX - touches[0].pageX), 2) + Math.pow(Math.abs(touches[1].pageY - touches[0].pageY), 2))\n\t};\n}\n\nvar Mixin = {\n\tpropTypes: {\n\t\tonPinchStart: PropTypes.func, // fires when a pinch gesture is started\n\t\tonPinchMove: PropTypes.func, // fires on every touch-move when a pinch action is active\n\t\tonPinchEnd: PropTypes.func // fires when a pinch action ends\n\t},\n\n\tonPinchStart: function onPinchStart(event) {\n\t\t// in case the two touches didn't start exactly at the same time\n\t\tif (this._initialTouch) {\n\t\t\tthis.endTouch();\n\t\t}\n\t\tvar touches = event.touches;\n\t\tthis._initialPinch = getPinchProps(touches);\n\t\tthis._initialPinch = Object.assign(this._initialPinch, {\n\t\t\tdisplacement: { x: 0, y: 0 },\n\t\t\tdisplacementVelocity: { x: 0, y: 0 },\n\t\t\trotation: 0,\n\t\t\trotationVelocity: 0,\n\t\t\tzoom: 1,\n\t\t\tzoomVelocity: 0,\n\t\t\ttime: Date.now()\n\t\t});\n\t\tthis._lastPinch = this._initialPinch;\n\t\tthis.props.onPinchStart && this.props.onPinchStart(this._initialPinch, event);\n\t},\n\n\tonPinchMove: function onPinchMove(event) {\n\t\tif (this._initialTouch) {\n\t\t\tthis.endTouch();\n\t\t}\n\t\tvar touches = event.touches;\n\t\tif (touches.length !== 2) {\n\t\t\treturn this.onPinchEnd(event); // bail out before disaster\n\t\t}\n\n\t\tvar currentPinch = touches[0].identifier === this._initialPinch.touches[0].identifier && touches[1].identifier === this._initialPinch.touches[1].identifier ? getPinchProps(touches) // the touches are in the correct order\n\t\t: touches[1].identifier === this._initialPinch.touches[0].identifier && touches[0].identifier === this._initialPinch.touches[1].identifier ? getPinchProps(touches.reverse()) // the touches have somehow changed order\n\t\t: getPinchProps(touches); // something is wrong, but we still have two touch-points, so we try not to fail\n\n\t\tcurrentPinch.displacement = {\n\t\t\tx: currentPinch.center.x - this._initialPinch.center.x,\n\t\t\ty: currentPinch.center.y - this._initialPinch.center.y\n\t\t};\n\n\t\tcurrentPinch.time = Date.now();\n\t\tvar timeSinceLastPinch = currentPinch.time - this._lastPinch.time;\n\n\t\tcurrentPinch.displacementVelocity = {\n\t\t\tx: (currentPinch.displacement.x - this._lastPinch.displacement.x) / timeSinceLastPinch,\n\t\t\ty: (currentPinch.displacement.y - this._lastPinch.displacement.y) / timeSinceLastPinch\n\t\t};\n\n\t\tcurrentPinch.rotation = currentPinch.angle - this._initialPinch.angle;\n\t\tcurrentPinch.rotationVelocity = currentPinch.rotation - this._lastPinch.rotation / timeSinceLastPinch;\n\n\t\tcurrentPinch.zoom = currentPinch.distance / this._initialPinch.distance;\n\t\tcurrentPinch.zoomVelocity = (currentPinch.zoom - this._lastPinch.zoom) / timeSinceLastPinch;\n\n\t\tthis.props.onPinchMove && this.props.onPinchMove(currentPinch, event);\n\n\t\tthis._lastPinch = currentPinch;\n\t},\n\n\tonPinchEnd: function onPinchEnd(event) {\n\t\t// TODO use helper to order touches by identifier and use actual values on touchEnd.\n\t\tvar currentPinch = Object.assign({}, this._lastPinch);\n\t\tcurrentPinch.time = Date.now();\n\n\t\tif (currentPinch.time - this._lastPinch.time > 16) {\n\t\t\tcurrentPinch.displacementVelocity = 0;\n\t\t\tcurrentPinch.rotationVelocity = 0;\n\t\t\tcurrentPinch.zoomVelocity = 0;\n\t\t}\n\n\t\tthis.props.onPinchEnd && this.props.onPinchEnd(currentPinch, event);\n\n\t\tthis._initialPinch = this._lastPinch = null;\n\n\t\t// If one finger is still on screen, it should start a new touch event for swiping etc\n\t\t// But it should never fire an onTap or onPress event.\n\t\t// Since there is no support swipes yet, this should be disregarded for now\n\t\t// if (event.touches.length === 1) {\n\t\t// \tthis.onTouchStart(event);\n\t\t// }\n\t}\n};\n\nmodule.exports = Mixin;"],"mappings":"AAAA,YAAY;;AAEZ,IAAIA,SAAS,GAAGC,OAAO,CAAC,YAAY,CAAC;AACrC,IAAIC,KAAK,GAAGD,OAAO,CAAC,OAAO,CAAC;AAE5B,SAASE,aAAa,CAACC,OAAO,EAAE;EAC/B,OAAO;IACNA,OAAO,EAAEC,KAAK,CAACC,SAAS,CAACC,GAAG,CAACC,IAAI,CAACJ,OAAO,EAAE,SAASK,SAAS,CAACC,KAAK,EAAE;MACpE,OAAO;QAAEC,UAAU,EAAED,KAAK,CAACC,UAAU;QAAEC,KAAK,EAAEF,KAAK,CAACE,KAAK;QAAEC,KAAK,EAAEH,KAAK,CAACG;MAAM,CAAC;IAChF,CAAC,CAAC;IACFC,MAAM,EAAE;MAAEC,CAAC,EAAE,CAACX,OAAO,CAAC,CAAC,CAAC,CAACQ,KAAK,GAAGR,OAAO,CAAC,CAAC,CAAC,CAACQ,KAAK,IAAI,CAAC;MAAEI,CAAC,EAAE,CAACZ,OAAO,CAAC,CAAC,CAAC,CAACS,KAAK,GAAGT,OAAO,CAAC,CAAC,CAAC,CAACS,KAAK,IAAI;IAAE,CAAC;IACtGI,KAAK,EAAEC,IAAI,CAACC,IAAI,EAAE,IAAIf,OAAO,CAAC,CAAC,CAAC,CAACS,KAAK,GAAGT,OAAO,CAAC,CAAC,CAAC,CAACS,KAAK,CAAC,IAAIT,OAAO,CAAC,CAAC,CAAC,CAACQ,KAAK,GAAGR,OAAO,CAAC,CAAC,CAAC,CAACQ,KAAK,CAAC,GAAG,GAAG,GAAGM,IAAI,CAACE,EAAE;IAClHC,QAAQ,EAAEH,IAAI,CAACI,IAAI,CAACJ,IAAI,CAACK,GAAG,CAACL,IAAI,CAACM,GAAG,CAACpB,OAAO,CAAC,CAAC,CAAC,CAACQ,KAAK,GAAGR,OAAO,CAAC,CAAC,CAAC,CAACQ,KAAK,CAAC,EAAE,CAAC,CAAC,GAAGM,IAAI,CAACK,GAAG,CAACL,IAAI,CAACM,GAAG,CAACpB,OAAO,CAAC,CAAC,CAAC,CAACS,KAAK,GAAGT,OAAO,CAAC,CAAC,CAAC,CAACS,KAAK,CAAC,EAAE,CAAC,CAAC;EAC5I,CAAC;AACF;AAEA,IAAIY,KAAK,GAAG;EACXC,SAAS,EAAE;IACVC,YAAY,EAAE3B,SAAS,CAAC4B,IAAI;IAAE;IAC9BC,WAAW,EAAE7B,SAAS,CAAC4B,IAAI;IAAE;IAC7BE,UAAU,EAAE9B,SAAS,CAAC4B,IAAI,CAAC;EAC5B,CAAC;;EAEDD,YAAY,EAAE,SAASA,YAAY,CAACI,KAAK,EAAE;IAC1C;IACA,IAAI,IAAI,CAACC,aAAa,EAAE;MACvB,IAAI,CAACC,QAAQ,EAAE;IAChB;IACA,IAAI7B,OAAO,GAAG2B,KAAK,CAAC3B,OAAO;IAC3B,IAAI,CAAC8B,aAAa,GAAG/B,aAAa,CAACC,OAAO,CAAC;IAC3C,IAAI,CAAC8B,aAAa,GAAGC,MAAM,CAACC,MAAM,CAAC,IAAI,CAACF,aAAa,EAAE;MACtDG,YAAY,EAAE;QAAEtB,CAAC,EAAE,CAAC;QAAEC,CAAC,EAAE;MAAE,CAAC;MAC5BsB,oBAAoB,EAAE;QAAEvB,CAAC,EAAE,CAAC;QAAEC,CAAC,EAAE;MAAE,CAAC;MACpCuB,QAAQ,EAAE,CAAC;MACXC,gBAAgB,EAAE,CAAC;MACnBC,IAAI,EAAE,CAAC;MACPC,YAAY,EAAE,CAAC;MACfC,IAAI,EAAEC,IAAI,CAACC,GAAG;IACf,CAAC,CAAC;IACF,IAAI,CAACC,UAAU,GAAG,IAAI,CAACZ,aAAa;IACpC,IAAI,CAACa,KAAK,CAACpB,YAAY,IAAI,IAAI,CAACoB,KAAK,CAACpB,YAAY,CAAC,IAAI,CAACO,aAAa,EAAEH,KAAK,CAAC;EAC9E,CAAC;EAEDF,WAAW,EAAE,SAASA,WAAW,CAACE,KAAK,EAAE;IACxC,IAAI,IAAI,CAACC,aAAa,EAAE;MACvB,IAAI,CAACC,QAAQ,EAAE;IAChB;IACA,IAAI7B,OAAO,GAAG2B,KAAK,CAAC3B,OAAO;IAC3B,IAAIA,OAAO,CAAC4C,MAAM,KAAK,CAAC,EAAE;MACzB,OAAO,IAAI,CAAClB,UAAU,CAACC,KAAK,CAAC,CAAC,CAAC;IAChC;;IAEA,IAAIkB,YAAY,GAAG7C,OAAO,CAAC,CAAC,CAAC,CAACO,UAAU,KAAK,IAAI,CAACuB,aAAa,CAAC9B,OAAO,CAAC,CAAC,CAAC,CAACO,UAAU,IAAIP,OAAO,CAAC,CAAC,CAAC,CAACO,UAAU,KAAK,IAAI,CAACuB,aAAa,CAAC9B,OAAO,CAAC,CAAC,CAAC,CAACO,UAAU,GAAGR,aAAa,CAACC,OAAO,CAAC,CAAC;IAAA,EACnLA,OAAO,CAAC,CAAC,CAAC,CAACO,UAAU,KAAK,IAAI,CAACuB,aAAa,CAAC9B,OAAO,CAAC,CAAC,CAAC,CAACO,UAAU,IAAIP,OAAO,CAAC,CAAC,CAAC,CAACO,UAAU,KAAK,IAAI,CAACuB,aAAa,CAAC9B,OAAO,CAAC,CAAC,CAAC,CAACO,UAAU,GAAGR,aAAa,CAACC,OAAO,CAAC8C,OAAO,EAAE,CAAC,CAAC;IAAA,EAC5K/C,aAAa,CAACC,OAAO,CAAC,CAAC,CAAC;;IAE1B6C,YAAY,CAACZ,YAAY,GAAG;MAC3BtB,CAAC,EAAEkC,YAAY,CAACnC,MAAM,CAACC,CAAC,GAAG,IAAI,CAACmB,aAAa,CAACpB,MAAM,CAACC,CAAC;MACtDC,CAAC,EAAEiC,YAAY,CAACnC,MAAM,CAACE,CAAC,GAAG,IAAI,CAACkB,aAAa,CAACpB,MAAM,CAACE;IACtD,CAAC;IAEDiC,YAAY,CAACN,IAAI,GAAGC,IAAI,CAACC,GAAG,EAAE;IAC9B,IAAIM,kBAAkB,GAAGF,YAAY,CAACN,IAAI,GAAG,IAAI,CAACG,UAAU,CAACH,IAAI;IAEjEM,YAAY,CAACX,oBAAoB,GAAG;MACnCvB,CAAC,EAAE,CAACkC,YAAY,CAACZ,YAAY,CAACtB,CAAC,GAAG,IAAI,CAAC+B,UAAU,CAACT,YAAY,CAACtB,CAAC,IAAIoC,kBAAkB;MACtFnC,CAAC,EAAE,CAACiC,YAAY,CAACZ,YAAY,CAACrB,CAAC,GAAG,IAAI,CAAC8B,UAAU,CAACT,YAAY,CAACrB,CAAC,IAAImC;IACrE,CAAC;IAEDF,YAAY,CAACV,QAAQ,GAAGU,YAAY,CAAChC,KAAK,GAAG,IAAI,CAACiB,aAAa,CAACjB,KAAK;IACrEgC,YAAY,CAACT,gBAAgB,GAAGS,YAAY,CAACV,QAAQ,GAAG,IAAI,CAACO,UAAU,CAACP,QAAQ,GAAGY,kBAAkB;IAErGF,YAAY,CAACR,IAAI,GAAGQ,YAAY,CAAC5B,QAAQ,GAAG,IAAI,CAACa,aAAa,CAACb,QAAQ;IACvE4B,YAAY,CAACP,YAAY,GAAG,CAACO,YAAY,CAACR,IAAI,GAAG,IAAI,CAACK,UAAU,CAACL,IAAI,IAAIU,kBAAkB;IAE3F,IAAI,CAACJ,KAAK,CAAClB,WAAW,IAAI,IAAI,CAACkB,KAAK,CAAClB,WAAW,CAACoB,YAAY,EAAElB,KAAK,CAAC;IAErE,IAAI,CAACe,UAAU,GAAGG,YAAY;EAC/B,CAAC;EAEDnB,UAAU,EAAE,SAASA,UAAU,CAACC,KAAK,EAAE;IACtC;IACA,IAAIkB,YAAY,GAAGd,MAAM,CAACC,MAAM,CAAC,CAAC,CAAC,EAAE,IAAI,CAACU,UAAU,CAAC;IACrDG,YAAY,CAACN,IAAI,GAAGC,IAAI,CAACC,GAAG,EAAE;IAE9B,IAAII,YAAY,CAACN,IAAI,GAAG,IAAI,CAACG,UAAU,CAACH,IAAI,GAAG,EAAE,EAAE;MAClDM,YAAY,CAACX,oBAAoB,GAAG,CAAC;MACrCW,YAAY,CAACT,gBAAgB,GAAG,CAAC;MACjCS,YAAY,CAACP,YAAY,GAAG,CAAC;IAC9B;IAEA,IAAI,CAACK,KAAK,CAACjB,UAAU,IAAI,IAAI,CAACiB,KAAK,CAACjB,UAAU,CAACmB,YAAY,EAAElB,KAAK,CAAC;IAEnE,IAAI,CAACG,aAAa,GAAG,IAAI,CAACY,UAAU,GAAG,IAAI;;IAE3C;IACA;IACA;IACA;IACA;IACA;EACD;AACD,CAAC;;AAEDM,MAAM,CAACC,OAAO,GAAG5B,KAAK"},"metadata":{},"sourceType":"script","externalDependencies":[]}